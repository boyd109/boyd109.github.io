<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>Midterm Notes</title>

  <meta name="author" content="Jonathan Tsang" />

  

  <link rel="alternate" type="application/rss+xml" title="Jonathan Tsang - A journey through Waterloo" href="/feed.xml" />

 <!-- everything has to be repeated twice because on 2016-02-01 GitHub pages migrated to jekyll 3; see bug https://github.com/jekyll/jekyll/issues/4439 -->

  
    
      <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" />
    
  
  

  
    
      <link rel="stylesheet" href="/css/bootstrap.min.css" />
    
      <link rel="stylesheet" href="/css/main.css" />
    
  
  

  
    
      <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
    
      <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
    
  
  

  
  

  
  

  
  

  <!-- Facebook OpenGraph tags -->
  <meta property="og:title" content="Midterm Notes" />
  <meta property="og:type" content="website" />

  
  <meta property="og:url" content="http://jonathantsang.github.io/2016-10-29-cs136_5//" />
  

  
  <meta property="og:image" content="" />
  

</head>


  <body>

    <!-- "navbar-custom" in nav below this to have expanding navbar like it originally had-->
<nav class="navbar navbar-default navbar-fixed-top navbar-custom no-transition">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="http://jonathantsang.github.io">Jonathan Tsang</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
      
        
          <li>
            
            




  


<a href="/aboutme">About Me</a>

          </li>
        
        
        
          <li>
            
            




  


<a href="/resume">Resume</a>

          </li>
        
        
        
          <li>
            
            




  


<a href="/projects">Projects</a>

          </li>
        
        
        
          <li>
            
            




  


<a href="/blog">Blog</a>

          </li>
        
        
        
          <li>
            
            




  


<a href="/notes">Notes</a>

          </li>
        
        
        
          <li>
            
            




  


<a href="/my-story">My Story</a>

          </li>
        
        
        
          <li class="navlinks-container">
            <a class="navlinks-parent" href="javascript:void(0)">Hackthons</a>
            <div class="navlinks-children">
              
                
                  
            




  


<a href="/mhacks8">MHacks8</a>

                
              
                
                  
            




  


<a href="/th5">TerribleHacks5</a>

                
              
                
                  
            




  


<a href="/mhacks9">Mhacks9</a>

                
              
                
                  
            




  


<a href="/hackprinceton2017">HackPrinceton2017</a>

                
              
            </div>
          </li>
        
        
        
          <li>
            
            




  


<a href="/hobbies">Hobbies</a>

          </li>
        
        
      </ul>
    </div>

<!--
	
-->

  </div>
</nav>
<nav class="navbar navbar-default">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="#">Brand</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li class="active"><a href="#">Link <span class="sr-only">(current)</span></a></li>
        <li><a href="#">Link</a></li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Dropdown <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="#">Action</a></li>
            <li><a href="#">Another action</a></li>
            <li><a href="#">Something else here</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="#">Separated link</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="#">One more separated link</a></li>
          </ul>
        </li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li><a href="#">Link</a></li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Dropdown <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="#">Action</a></li>
            <li><a href="#">Another action</a></li>
            <li><a href="#">Something else here</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="#">Separated link</a></li>
          </ul>
        </li>
      </ul>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>


    <!--
<div class="intro-header"></div>
-->
<html>
<div role="main" class="container">
  <h2 id="cs-136-midterm-notes">CS 136 Midterm Notes</h2>

<p>module: provides a collection of functions that share a common aspect or purpose.</p>

<h2 id="modularization">modularization:</h2>
<ul>
  <li>sharing among a team is easier</li>
  <li>can use helper function that help other functions</li>
  <li>good style to store each module in a separate file (if it breaks, fix module, not whole program)
main reasons for modularization:</li>
  <li>re-usability: re-used and construct large programs more easily</li>
  <li>maintainability: easier to test and debug a single module</li>
  <li>abstraction: understand what functionality it provides, but not need to understand how it is implemented</li>
</ul>

<p>terminology:
- client requires functions that a module provides
- module dependency graph cannot have any cycles
- root or main file acts as a client</p>

<h2 id="scope">Scope:</h2>
<ul>
  <li>local only visible inside of the local region (or function body) where it is defined</li>
  <li>global identifiers are defined at the top level and are visible to all code following the definition</li>
</ul>

<p>global can have either program or module scope:
- module identifiers are only visible in the module(file) they are defined in
- program identifiers are visible outside of the module they are defined in</p>

<p>Module Interface
- module interface is a list of functions that the module provides
- implementation is the code, interface is what the client would need to use the module
- interface is provided, implementation is hidden</p>

<p>Interface documentation:
- overall description of the module
- list of functions it provides
- contract and purpose for each provided function
- white box tests cannot be tested by a client</p>

<p>Designing Modules:
- high cohesion all interface functions work towards a “common goal”
- low coupling little interaction between modules</p>

<p><img src="/classes/3a/cs136/coupling.png" alt="Coupling Info" /></p>

<h2 id="interface-vs-implementation">Interface vs Implementation</h2>
<ul>
  <li>information hiding where the interface is designed to hide any implementation details from the client</li>
  <li>security is important because it prevents the client from tampering with data used by the module</li>
  <li>flexibility to change the implementation in the future</li>
</ul>

<p>Data structures and abstract data types
- abstract data type
- implemented as data storage modules and the implementation is hidden from the client</p>

<p>dictionary adt:
- lookup: keys and retrieve corresponding value
- insert: add a new key/value pair
- remove: deletes a key and its value</p>

<p>stack: only touch top
queue: lineup
sequence: line where remove anywhere in adt</p>

<p>stack:
push: add new item to top
pop: remove top item
top: returns the top item
is-empty: determines if it is empty</p>

<p>queue:
add-back: add item to the end
remove-front: remove from the front
front: returns the item at the front
is-empty: determines if the queue is empty</p>

<p>sequence:
item-at: returns the item at given position
insert-at: insert new item at given position
remove-at: removes an item at given position
length: return number of items in sequence</p>

<p>C names must start with a letter, and only contain letters, underscores, and numbers</p>

<h2 id="typing">Typing:</h2>
<p>Racket uses dynamic typing: the type of the identifier is determined while the program is running
C uses static typing: the type of the identifier must be known before the program is run. (The type is declared in the definition and cannot change)</p>

<p>Initialization:
<code>
const int my_number = 42;
</code>
“= 42” is called the initialization</p>

<p>C operators
- (+, -, *, \/)
- / operator rounds towards zero</p>

<p>The % operator: (remainder)
- modulo
- 21 % 2 = 1</p>

<h2 id="function-terminology">Function Terminology:</h2>
<ul>
  <li>call a function, function is passed, returns a value</li>
</ul>

<h2 id="entry-point">Entry Point:</h2>
<ul>
  <li>OS needs to know where to start, this is called the entry point</li>
  <li>most languages entry point is at the top, for C the entry point is the special function main</li>
  <li>main successful is zero, and if an error occurs it is non-zero</li>
  <li>return optional, defaults to zero</li>
  <li>printf part of C stdio (standard i/o module)</li>
  <li>“%04d\n” pad with 0s to make it 4 digits long</li>
  <li>similar to Racket, C short-circuits and stops evaluating an expression when the value is known</li>
</ul>

<h2 id="functions">Functions</h2>
<ul>
  <li>a function (or identifier) must be declared before any expression it appears in</li>
  <li>a <strong>declaration</strong> communicates to C the type of an identifier</li>
  <li>subtle difference between definition and declaration</li>
  <li>declaration: specifies the type of an identifier (like a movie trailer)</li>
  <li>definition instructs C to “create” the identifier (definition includes a declaration) (the actual movie)</li>
  <li>extern declares variables but not defined</li>
</ul>

<h2 id="c-modules">C Modules:</h2>
<ul>
  <li>no built-in functions in C</li>
  <li>standard modules (or libraries) with many useful functions</li>
  <li>stdio standard module provides the printf function</li>
  <li>some assert, stdbool, limits, string, stdlib</li>
  <li>to include stdio module:
#include <stdio.h></stdio.h></li>
  <li>to include a “regular” module:
#include “mymodule.h”</li>
</ul>

<h2 id="creating-a-module-in-c">Creating a Module in C</h2>
<ul>
  <li>place interface and the implementation into separate files</li>
  <li>interface (.h) we place declarations for the functions and variables that the module provides</li>
  <li>in the implementation (.c) we place all of the definitions</li>
</ul>

<h2 id="include">#include</h2>
<ul>
  <li>preprocessor directive</li>
</ul>

<h2 id="scope-1">Scope</h2>
<ul>
  <li>Racket each global identifier has module scope</li>
  <li>C each global identifier has program scope</li>
  <li>to declare a C global function or variable has module scope, ‘static’ keyword is used</li>
  <li>C cannot have any top-level expressions</li>
</ul>

<h2 id="assert-standard-module">Assert standard module</h2>
<ul>
  <li>assert(e) stops when the expression s is false, and if e is true, nothing happens</li>
  <li>assert the requirements when feasible</li>
</ul>

<h2 id="bool-type">bool type:</h2>
<ul>
  <li>stdbool standard module</li>
</ul>

<h2 id="floating-point-type">floating point type</h2>
<ul>
  <li>inexact numbers in Racket</li>
  <li>double is still inexact but has significantly better precision</li>
</ul>

<h2 id="structures">Structures</h2>
<p>(struct posn (x y))  (in C)
<code>
struct posn {
  int x;
  int y;
};
</code>
- structure operator (.) which selects the value from the requested field
- equality operator does not work with structures, must define own equality function
- “return {px. * f, p.y * f}” is INVALID</p>

<h2 id="chapter-4-imperative-c">Chapter 4: Imperative C</h2>
<ul>
  <li>functional means to produce a value depending only on the parameters</li>
  <li>functional programming paradigm is to only use constant values that never change, functions produce new ones rather than existing ones</li>
  <li>imperative uses a sequence of statements to give instructions to the computer</li>
  <li>begin in C is similar to local in Racket</li>
</ul>

<h2 id="side-effects">Side Effects</h2>
<ul>
  <li>printf is a side effect with output</li>
  <li>functional programming has no side effects</li>
  <li>add effects to a contract if there are any side effects</li>
  <li>printf returns the number of characters printed</li>
  <li>expression statement is followed by a semicolon, and the value at the end of the expression is ignored</li>
</ul>

<h2 id="block-statements">Block Statements</h2>
<ul>
  <li>a block ({}) is a compound statement that contains a sequence of statements</li>
  <li>a C block ({}) is similar to Racket’s begin statemetns that are evaluated in sequence</li>
  <li>a block ({}) does not “produce” a value, so return is needed</li>
  <li>a block can contain local scope definitions which are not statements
two types of C statements:</li>
  <li>compound statements (a sequence of statements)</li>
  <li>expression statements (for producing side effects)</li>
  <li>other type is control flow statements</li>
</ul>

<h2 id="control-flow-statements">Control Flow Statements</h2>
<ul>
  <li>return leaves a function to return a value</li>
  <li>if (and else) statements execute statements conditionally</li>
</ul>

<p><img src="/classes/3a/cs136/cterminology.png" alt="Coupling Info" /></p>

<h2 id="state">State</h2>
<ul>
  <li>defining imperative programming paradigm is the manipulative state</li>
  <li>state ‘moment in time’</li>
  <li>in a program each variable is in a specific state</li>
  <li>functional programming, each variable has only one possible state</li>
  <li>imperative programming, each variable can be one of many possible states</li>
  <li>hence the name variable can change during the execution of the program</li>
</ul>

<h2 id="mutation">Mutation</h2>
<ul>
  <li>changing variable</li>
  <li>good style to use const</li>
  <li>mutation achieved with assignment operator (=)
<code>
int m = 5; //initialization
m = 28;    //assignment operator
</code></li>
</ul>

<p>= used in initialization is <strong>not</strong> the assignment operator</p>

<ul>
  <li>functional programming paradigm, a function cannot have any side effects and the value it produces depends only on the parameters</li>
  <li>imperative programming paradigm a function may have side effects and its behaviour may depend on the state of the program</li>
</ul>

<p>prefer:
++x;
–x;<br />
over:<br />
x++;
x–;</p>

<h2 id="chapter-5-memory-and-control-flow">Chapter 5 Memory and Control Flow</h2>
<ul>
  <li>one bit of storage (in memory) has two possible states: 0 or 1</li>
  <li>a byte is 8 bits in store, each byte in memory is in one of the 256 possible states</li>
  <li>position of the byte is the address</li>
</ul>

<p>C encounters a variable definition:
- reserves or finds space in memory to store a variable
- “keeps track of” the address of that storage location
- stores the initial value of the variable at that location</p>

<ul>
  <li>variable definition reserves space, but a declaration does not.</li>
</ul>

<h2 id="sizeof-for-int">sizeof for int</h2>
<ul>
  <li>how much space in memory depends on the type of variable</li>
  <li>size operator produces the number of bytes to store a type</li>
  <li>int is 4 bytes, only <script type="math/tex">2^32</script> possible values (4,294,967,296)</li>
  <li>%zd is placeholder for a size</li>
  <li>int storage in memory is 4 consecutive bytes of memory</li>
  <li>integer limits -<script type="math/tex">2^{31}</script> to <script type="math/tex">2^{31}</script>-1</li>
  <li>using #include<limits.h> has constants INT_MIN and INT_MAX</limits.h></li>
</ul>

<p>overflow occurs when it goes under the int_min or over the int_max</p>

<h2 id="char-type">char type</h2>
<ul>
  <li>one byte of storage for a char</li>
  <li><script type="math/tex">2^8</script> (256) possible values for a char and the range of values (-128, … 127)</li>
</ul>

<h2 id="ascii">ASCII</h2>

<h2 id="c-characters">C Characters</h2>
<ul>
  <li>single quotes (‘) use to indicate ASCII characters
<code>
char letter_a = 'a';
char ninety_seven - 97;
</code>
both are the exact same</li>
</ul>

<h2 id="sructure-in-memory">Sructure in Memory</h2>
<ul>
  <li>only reserved when a struct variable is defined</li>
  <li>amount of space is <strong>at least</strong> the sum of sizeof each field, but may be larger</li>
  <li>floats have more precision, more memory used</li>
</ul>

<h2 id="sections-of-memory">Sections of Memory</h2>
<ul>
  <li>code, read-only data, global data, heap, stack</li>
  <li>section combined into memory segments</li>
  <li>memory outside is a segmentation fault</li>
</ul>

<h2 id="code">Code</h2>
<ul>
  <li>converted to machine code that is ‘machine readable’</li>
  <li>machine code placed in code section</li>
</ul>

<h2 id="read-only-and-global-data-sections">Read-only and Global Data Sections</h2>
<ul>
  <li>global variables are placed in read-only data section (constants) OR global data section (mutable variables)</li>
  <li>global variables’ space is reserved before the program begins execution</li>
  <li>code from program (and modules) is scanned and all global variables are identified</li>
  <li>next space for each global variable is reserved</li>
  <li>memory is properly initialized, this happens before main is called</li>
</ul>

<h2 id="control-flow">Control Flow</h2>
<ul>
  <li>keep track of program location</li>
  <li>when a function is called, the program jumps to the start of the function</li>
  <li>return “returns” back to the location of the calling function</li>
  <li>location to remember where to jump back is called the “return address”</li>
</ul>

<h2 id="call-stack">Call Stack</h2>
<ul>
  <li>history is known as the call stack</li>
  <li>each time a function is called, a new entry is pushed to the stack</li>
  <li>when return occurs the entry is popped off the stack</li>
</ul>

<h1 id="stack-frames">Stack Frames</h1>
<ul>
  <li>entries pushed onto the call stack are known as stack frames</li>
  <li>each function call creates a stack frame
stack frame contains:</li>
  <li>argument values</li>
  <li>local variables</li>
  <li>
    <p>return address</p>
  </li>
  <li>with Racket, before a function is called, all of the arguments must be values</li>
  <li>C makes a COPY of each argument value and places the copy in the stack frame</li>
  <li>space for local variable is only reserved <strong>when the function is called</strong></li>
  <li>space is reserved within a newly created stack frame</li>
  <li>when the function returns the variable (and the entire frame) is popped and effectively “disappears”</li>
</ul>

<h2 id="stack-section">Stack Section</h2>
<ul>
  <li>bottom of the stack is placed at the highest available memory address</li>
</ul>

<h2 id="uninitialized-memory">Uninitialized Memory</h2>
<ul>
  <li>all global variables will automatically initialize the variable to zero</li>
  <li>local variable has an arbitrary initial value</li>
</ul>

<h2 id="model">Model</h2>
<ul>
  <li>state has combination of program location and memory</li>
  <li>calling a function is control flow</li>
  <li>stack frame is created</li>
  <li>copy of argument is placed in the stack frame</li>
  <li>current program location is placed in the stack frame as the return address</li>
  <li>program location is changed to the start of the new function</li>
  <li>initial values of local variables are set when their definition is encountered</li>
</ul>

<h2 id="return">Return</h2>
<ul>
  <li>when it returns current program location changes back to the return address</li>
  <li>stack frame is removed (“popped from Stack memory”)</li>
</ul>

<p>If Statement</p>

<h2 id="loops">Loops</h2>
<ul>
  <li>while(expression) statement</li>
  <li>loops repeatedly until the expression is false</li>
  <li>a <strong>copy</strong> of each argument is passed to the function, so the function sum is free to mutate its own copy of k</li>
</ul>

<h2 id="while-errors">While Errors</h2>
<ul>
  <li>endless loops</li>
</ul>

<h2 id="do-while">Do While</h2>
<ul>
  <li>statement is always executed at least once, and the expression is checked at the end of the loop</li>
</ul>

<h2 id="break">Break</h2>
<ul>
  <li>break form  the middle of a loop</li>
  <li>terminates from the (innermost) loop</li>
  <li>usually breaks a (purposefully) infinite loop</li>
</ul>

<h2 id="continue">Continue</h2>
<ul>
  <li>control flow statement that skips over the rest of the statements in the current block ({}) and “continues” with the loop</li>
</ul>

<h2 id="for-loop">For Loop</h2>
<ul>
  <li>for(setup; expression; update) { body statement(s) }</li>
  <li>setup can include a definition</li>
</ul>

<h2 id="chapter-6-pointers">Chapter 6 Pointers</h2>

<h2 id="address-operator">Address Operator</h2>
<ul>
  <li>expose underlying memory model</li>
  <li>address operator (&amp;) produces the starting address of where the value of an identifier is stored in memory</li>
  <li>printf placeholder to display an address is “%p”</li>
  <li>storing an address a pointer</li>
  <li>value of a pointer of a address</li>
  <li>size of a pointer is always 8 bytes (regardless of type of data stored at that address)</li>
</ul>

<h2 id="indirection-operator">Indirection Operator</h2>
<ul>
  <li>(*) known as the dereference operator is the inverse of (&amp;)</li>
  <li>*p produces the value of what pointer p “points at”</li>
</ul>

<h2 id="pointers-to-pointers">Pointers to Pointers</h2>
<ul>
  <li>pointer p points to p is an error
<code>
int *p = &amp;p;
</code></li>
</ul>

<h2 id="null-pointer">Null Pointer</h2>
<ul>
  <li>points to “nothing” or “invalid”</li>
  <li>if you dereference a NULL pointer, the program will probably will likely crash</li>
</ul>

<h2 id="function-pointers">Function Pointers</h2>
<ul>
  <li>Racket, functions are first-class values</li>
  <li>Racket functions are values stored in variables and data structures</li>
  <li>in C, functions are not first-class values, but <strong>function pointers</strong> are
```
int add 1(int i) {return i + 1;}</li>
</ul>

<p>int main(void){
    int (*fp)(int) = add1;
    printf(“add1(3) = %d\n”, fp(3));
  }</p>

<p>add1(3) = 4
```
## Mutation &amp; Parameters
- “pass by value” in C, copy of an argument is passed to a function
- “pass by reference” where a variable is passed to a function can be changed by the function
- C can emulate pass by reference by passing the address of the variable we want the function to change (still considered “pass by value” since we pass the <strong>value</strong> of the address)</p>

<ul>
  <li>don’t return an address in its stack frame because all memory within the frame should be considered invalid</li>
</ul>

<h2 id="passing-structures">Passing Structures</h2>
<ul>
  <li>a <strong>copy</strong> of each argument value is placed into a stack frame, for large struct this can be inefficient</li>
  <li>arrow selection operator (-&gt;) combines the indirection and the selection operators</li>
</ul>

<h2 id="const-parameters-and-pointers">Const Parameters and Pointers</h2>
<p><code>
void cannot_change(const struct posn *p){
    p-&gt;x = 5; // INVALID
}
</code>
p can change, but must always point at a const int
The rule is “const” applies to the type to the left of it, unless it’s first, and then it applies to the type to the right of it.
<code>
int my_function(const int x){
    //mutation of x here is invalid
    // ...
}
</code>
Because a <strong>copy</strong> of the argument is made for the stack, it does not matter if the original argument value is constant or not. A <strong>const</strong> parameter communicates that <strong>the copy</strong> will not be mutated</p>

<h2 id="opaque-structures-in-c">Opaque Structures in C</h2>
<p>```
struct posn; // INCOMPLETE</p>

<p>struct posn my_posn; // INVALID
struct posn *posn_ptr // VALID
```</p>

<h2 id="chapter-7-io-testing">Chapter 7 I/O Testing</h2>
<p>Input &amp; Output (I/O for short)
- scanf(“%d”, &amp;i); // read in an integer, store in i
- return value of scanf is the number of values successfully read in
```
count = scanf(“%d”, &amp;i);</p>

<p>if (count != 1){
    printf(“Fail! I could not read in an integer!\n”);”)
}
```
scanf(“%d”, &amp;i) will ignore whitespace (spaces and newlines) and read in the next integer
If the next non-whitespace input to be read in is not a valid integer (e.g. a letter), it will stop reading and return zero</p>

<h2 id="chapter-8-arrays-and-strings">Chapter 8 Arrays and Strings</h2>
<ul>
  <li>two built-in “compound” data storage:
structures and arrays
<code>
int my_array[6] = {4,8,15,16,23,42}
</code></li>
  <li><strong>fixed number</strong> of elements and all have the <strong>same type</strong></li>
  <li>to define an array we know the <strong>length</strong> of the array in advance</li>
  <li>each individual value in the array is known as an element</li>
  <li>to access an element, its index is required</li>
  <li>index starts at 0</li>
  <li>entire array cannot be assigned at once</li>
  <li>each individual element must be mutated</li>
  <li>unitialized <strong>global</strong> arrays are zero-filled</li>
  <li>unitialized <strong>local</strong> arrays are filled with arbitrary (“garbage”) values from the stack</li>
  <li>remaining values are initialized to zero (even with local arrays)
<code>
int b[5] = {1,2,3}; // b[3] &amp; b[4] = 0
int c[5] = {0}; // c[0] ... c[4] = 0
</code>
length can be omitted and automatically determined from number of elements in initialization
<code>
int b[]; // INVALID
</code>
Only valid if the array is initialized</li>
</ul>

<h2 id="array-size">Array Size</h2>
<ul>
  <li>length if number of elements in the array</li>
  <li>size is the number of bytes it occupies in memory</li>
  <li>array of k elements is, each size s is k x s bytes</li>
</ul>

<p>Array of siz elements (int a[6]) is (6 x 4 = 24)</p>

<p>C does not keep track of the array length as part of the array data structure</p>

<h2 id="array-identifier">Array identifier</h2>
<ul>
  <li>value of an array (a) is the same as the <strong>address</strong> of the array (&amp;a) which is also the address of the first element (&amp;a[0])</li>
</ul>

<h2 id="passing-arrays-to-functions">Passing Arrays to Functions</h2>
<ul>
  <li>only the <strong>address</strong> of the array is copied to the stack frame, this is more efficient than copying the entire array to the stack</li>
</ul>

<h2 id="pointer-arithmetic">Pointer Arithmetic</h2>
<ul>
  <li>if p is a pointer, (p + 1) <strong>depends on the type</strong> of the pointer p</li>
  <li>(p + 1) adds the sizeof whatever p points at</li>
  <li>rule is p + i x sizeof(*p)</li>
  <li>subtracting works the same way</li>
  <li>mutable pointers can be incremented or decremented (++p is equivalent to p = p + 1)</li>
  <li>can’t add two pointers</li>
  <li>subtract two pointers if they are the same type:
(p - q)/sizeof(*p)</li>
  <li>pointers of the same type can be compared with comparison operators &lt;,&lt;=, ==, !=, &gt;=, &gt;</li>
</ul>

<h2 id="pointer-arithmetic-and-arrays">Pointer Arithmetic and Arrays</h2>
<ul>
  <li>a[i] is equivalent to *(a + 1)</li>
</ul>

<h2 id="array-map">Array Map</h2>
<p><code>
// effects: replaces each element a[i] with f(a[i])
  void array_map(int (*f)(int), int a[], int len) {
    for (int i=0; i &lt; len; ++i) {
      a[i] = f(a[i]);
    }
}
</code></p>

</div>
</html>


    <footer>
  <div class="container beautiful-jekyll-footer">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
          
          <li>
            <a href="https://github.com/jonathantsang" title="GitHub">
              <span class="fa-stack fa-lg">
                <i class="fa fa-circle fa-stack-2x"></i>
                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
		  
		  
          <li>
            <a href="mailto:j26tsang@gmail.com" title="Email me">
              <span class="fa-stack fa-lg">
                <i class="fa fa-circle fa-stack-2x"></i>
                <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
		  
		  
		  
        </ul>
        <p class="copyright text-muted">
		  This site is updated by Jonathan Tsang
		  &nbsp;&bull;&nbsp;
		  2017

		  
		  &nbsp;&bull;&nbsp;
		  <a href="http://jonathantsang.github.io">jonathantsang.github.io</a>
		  
	    </p>
	        <!-- Please don't remove this, keep my open source work credited :) -->
		<p class="theme-by text-muted">
		  <a href="http://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a>
		</p>
      </div>
    </div>
  </div>


    <!-- everything has to be repeated twice because on 2016-02-01 GitHub pages migrated to jekyll 3; see bug https://github.com/jekyll/jekyll/issues/4439 -->












  
    <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
    
      <script>
      	if (typeof jQuery == 'undefined') {
      	  document.write('<script src="/js/jquery-1.11.2.min.js"></scr' + 'ipt>');
      	}
      </script>
    
  
    <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
    
	<script src="/js/bootstrap.min.js"></script>
    
  
    <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
    
	<script src="/js/main.js"></script>
    
  





    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-84758502-1', 'auto');
  ga('send', 'pageview');

</script>


  </body>
</html>
